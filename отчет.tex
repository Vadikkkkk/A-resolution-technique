\documentclass[12pt, a4paper]{article}
\usepackage[left=30mm, top=20mm, right=15mm, bottom=20mm,nohead,nofoot]{geometry}
\linespread{1.3}
\usepackage{graphicx}
\usepackage{indentfirst}
\setlength{\parindent}{1.25cm}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\thepage}
\fancyheadoffset{0mm}
\fancyfootoffset{0mm}
\setlength{\headheight}{17pt}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
\fancypagestyle{plain}{ 
	\fancyhf{}
	\rhead{\thepage}}

\setcounter{page}{2}

\usepackage[english, russian]{babel}
\usepackage[utf8]{inputenc}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{array}

\usepackage{setspace}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{xcolor}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{cppstyle}{
	language=C++,
	basicstyle=\ttfamily\footnotesize,
	keywordstyle=\color{codepurple},
	stringstyle=\color{red},
	commentstyle=\color{green!60!black},
	backgroundcolor=\color{backcolour},
	numbers=left,
	numberstyle=\tiny\color{black},
	breaklines=true,
	showstringspaces=false,
	frame=none,
	tabsize=2,
	inputencoding=utf8,
	captionpos=b
}

\lstset{style=cppstyle}

\lstnewenvironment{cppcode}[1][]
{
	\lstset{
		style=cppstyle,
		#1
	}
	\setstretch{1}
}
{}



\usepackage{amsfonts}
\usepackage{textgreek}
\usepackage[colorlinks=true, urlcolor=blue, linkcolor=black]{hyperref}
\newcommand{\RomanNumeralCaps}[1]
{\MakeUppercase{\romannumeral #1}}
\usepackage{alltt}
\usepackage{caption}
\captionsetup[table]{labelsep=period}  % Заменяет двоеточие на точку
\captionsetup[figure]{labelsep=period}
\captionsetup[lstlisting]{labelsep=period}
\usepackage{cleveref}

\usepackage{titlesec}
\DeclareGraphicsExtensions{.png, .pdf, .jpg}

\titleformat{\section}[block]{\Large\bfseries\centering}{\thesection}{1em}{}
\titleformat{\subsection}[block]{\large\bfseries\centering}{\thesubsection}{1em}{}
\titleformat{\subsubsection}[block]{\itshape\bfseries\centering}{\thesubsubsection}{1em}{}

\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

\date{}
%%% стиль оформления глав, параграфов и  etc %%%
\def\thesection{}
\def\thesubsection{\S\,\,\arabic{section}.\arabic{subsection}.\,}
\def\thesubsubsection{\arabic{section}.\arabic{subsection}.\arabic{subsubsection}.\,}
\def\theequation{\arabic{section}.\arabic{equation}}

\begin{document}
	\begin{center}
		\renewcommand{\contentsname}{\MakeUppercase{Содержание}}
		\tableofcontents{}
		
	\end{center}
	\setcounter{page}{2}
	\newpage
	\setcounter{subsection}{0}
	\setcounter{equation}{0}
	\setcounter{section}{0}
	
	\section*{\centering ВВЕДЕНИЕ}
	\addcontentsline{toc}{section}{Введение}
	
	\par В данной практической работе исследуется реализация метода резолюций в логике высказываний на языке программирования C++. Метод резолюций является фундаментальным инструментом в области автоматического доказательства теорем в логике высказываний.
	\par Актуальность данной работы обуславливается значимостью метода резолюций в области формальных методов и искусственного интеллекта. Применение данного метода позволяет автоматизировать процесс вывода логических заключений, что важно для разработки и верификации программного обеспечения, а также для исследований в области математики и логики.
	\par Целью данной практической работы является изучение теоретических основ метода резолюций, его реализация на языке C++ с помощью фреймворка Qt и анализ результатов работы программы.
	\par Для достижения поставленной цели были сформулированы следующие задачи:
	\begin{enumerate}
		\item Изучить основные принципы метода резолюций в контексте логики высказываний.
		\item Разработать программу на языке C++, используя фреймфорк Qt, реализующую метод резолюций.
		\item Провести тестирование программы на различных логических задачах и проверить её корректность.
		\item На основании проделанной работы сделать вывод о перспективах использования метода резолюций в современных исследованиях и практических приложениях.
	\end{enumerate}
	
	
	\newpage
	
	
	\addtocounter{section}{+1}
	\section*{\centering ГЛАВА 1. ТЕОРЕТИЧЕСКАЯ ЧАСТЬ}
	\addcontentsline{toc}{section}{Глава 1. Теоретическая часть}
	
	\setcounter{section}{1}
	
	\begin{center}
		\subsection{Введение}
	\end{center} 
	\par В данной главе мы рассмотрим теоретичские основы метода резолюций. В начале будет приведена историческая справка о развитии логики и, в частности, математической логики. Далее будут введены основные понятия метода для логики высказываний и рассмотрен метод резолюций для логики высказываний. Также будет рассмотрена теорема о полноте для логики высказываний, а в конце главы обсуждаются стратегии метода, применения метода для доказательства теорем и решения задачи планирования действий, взаимосвязь метода и логического программирования.
	
	\begin{center}
		\subsection{Историческая справка}
	\end{center} 
	 \par Термином \textbf{«логика» }называется наука, изучающая формы и законы мышления, способы построения доказательств и опровержений различных утверждений. [1] Логика берет начало от работ древнегреческого философа Аристотеля (4 век до нашей эры). Он первым обратил внимание на то, что при выводе одних утверждений из других исходят не из конкретного содержания рассуждений, а из взаимоотношения между их формами. Логика Аристотеля усовершенствовалась на протяжении многих веков. Значительный качественный прогресс в развитии логики наступил с применением в логике математических методов.
	 \par Возникновение науки, которая называется \textbf{математической логикой}, связывают с работами аглийского математика и логика Д. Буля. Им была создана \textbf{алгебра логики} – результат применения к логике алгебраических методов. В 20 веке на базе математической логики была разработана теория алгоритмов. В разработку этой теории внесли существенный вклад английский математик А. Тьюринг и американский математик Э. Пост. 
	 \par Математическая логика в течение всего периода развития имела применение как в математике, так и вне ее. Весьма значительны применения математической логики в кибернетике и информатике. Так, одной из основных задач искусственного интелекта является разработка моделей представления знаний. Кроме стредств описания знаний, модель должна обладать и дедуктивными возможностями - уметь получать следствия из некторой исходной информации. Этим требованиям в полной мере удовлетворяют логические модели, в основе которых лежит математическая логика.
	 
	 \begin{center}
	 	\subsection{Основные понятия логики высказываний}
	 \end{center} 
	 \par \textbf{Логика высказываний }- это простейший раздел математической логики, изучающий сложные высказывания, образованные из простых, и их взаимоотношения. Основным понятием логики высказываний явзяется \textbf{высказывание} - утвердительное предложение, которое может быть истинным или ложным, но не тем и другим вместе. [2] Примеры высказываний: <<Снег белый>> , <<Яблоко сладкое>>, <<Яблоко большое>>. Каждое высказывание имеет <<значение истинности>>. Условимся использовать заглавные буквы для обозначения высказываний. Например обозначим данные высказывания:
	 \begin{itemize}
	 	\item A = <<Снег белый>>
	 	\item B = <<Яблоко сладкое>>
	 	\item C = <<Яблоко большое>>
	 \end{itemize}
	 Символы A, B, C и т.д., которые используются для обозначения высказываний, называются атомарной формулой или \textbf{литералом}.
	 \par Из высказываний мы можем строить составные высказывания, используя \textbf{логические связки}. В логике высказываний используются пять логических связок:
	 \begin{enumerate}
	 	\item $\lor$ - дизъюнкция (или)
	 	\item $\land$ - конъюнкция (и)
	 	\item $\neg$ - отрицание (не)
	 	\item $\rightarrow$ - импликация (если ... , то ...)
	 	\item $\leftrightarrow$ - равносильность (тогда и только тогда, когда) 
	 \end{enumerate}
	 Составим таблицу истинности связок:
	 \begin{table}[h!]
	 	\centering
	 	\begin{tabular}{|c|c|c|c|c|c|c|c|}
	 		\hline
	 		$A$ & $B$ & $\neg A$ & $A \land B$ & $A \lor B$ & $A \rightarrow B$ & $A \leftrightarrow B$ \\ \hline
	 		1 & 1 & 0 & 1 & 1 & 1 & 1 \\ \hline
	 		1 & 0 & 0 & 0 & 1 & 0 & 0 \\ \hline
	 		0 & 1 & 1 & 0 & 1 & 1 & 0 \\ \hline
	 		0 & 0 & 1 & 0 & 0 & 1 & 1 \\ \hline
	 	\end{tabular}
	 	\caption{Таблица истинности связок}
	 \end{table}\\
	 Эти пять связок используются для построения более сложных составных высказываний. Пример составного высказывания: B $\land$ C = <<Яблоко сладкое и Яблоко большое>>.  В логике высказываний высказывание или составное высказывание называется \textbf{формулой}. Формулы в логике высказываний определяются рекурсивно следующим образом:
	 \begin{enumerate}
	 	\item Атом (литерал) есть формула.
	 	\item Если A - формула, то $\neg$A - формула.
	 	\item Если A и B - формулы, то (A $\land$ B), (A $\lor$ B), (A $\rightarrow$ B), (A $\leftrightarrow$ B) - формулы.
	 	\item Никаких формул, кроме порожденных применением указанных выше правил, нет.
	 \end{enumerate}
	 \par Существую формулы, которые истинны при всех возможных интерпретациях и ложны при всех возможных интерпретациях, такие формулы называют общезначимыми и противоречивыми соответственно.
	 \par Говорят, что две формулы A и B эквивалентны, тогда и только тогда, когда значения истинности A и B совпадают при каждой интерпретации A и B.
	 \par Одна из основных целей изучения логики состоит в получении формального аппарата для доказательства того, является ли данное утверждение следствием других. Это приводит нас к понятию \textbf{<<логического следствия>>}. 
	 \par Пусть даны формулы $F_{1}, F_{2},  ... , F_{n}$ и формула $G$. Говорят, что $G$ есть \textbf{логическое следствие} формул $F_{1}, F_{2}, ... , F_{n}$ (или $G$ логически следует из $F_{1}, F_{2}, ... , F_{n}$) если для всякой интерпретации $\phi$ из того, что $\phi (F_{1}) = \phi (F_{2}) = ... = \phi (F_{n}) = 1$, следует, что $\phi(G) = 1$. $F_{1}, F_{2}, ... , F_{n}$ называются аксиомами (посылками) $G$.
	 \par Понятие логического следствия тесно связано с понятие выполнимости. Множество формул $ \{F_{1}, F_{2}, ... , F_{n}\}$ называется выполнимым, если существует такая интерпретация $\phi$, что $\phi (F_{1}) = \phi (F_{2}) = ... = \phi (F_{n}) = 1$.
	 
	 \begin{center}
	 	\subsection{Метод резолюций в логике высказываний}
	 \end{center} 
	 \par Для изучения метода резолюций нам понадобится следующее утверждение.\\
	 \par \textbf{Теорема 1.} Формула $G$ является логическим следствием формул $F_{1}, F_{2}, ... , F_{n}$ тогда и только тогда, когда множество формул $L = \{ F_{1}, F_{2}, ... , F_{n}, \neg G\}$ невыполнимо. \\
	 \par \textbf{\textit{Доказательство:}} Пусть формула $G$ является логическим следствием формул $F_{1}, ... , F_{k}$. Предположим, что множество $L$ выполнимо. Это означает, что существует интерпретация $\psi$ такая, что $\psi(F_{1}) = ... = \psi(F_{k}) = \psi(\neg G) = 1$. Но если $\psi(F_{1}) = ... = \psi(F_{k}) = 1$, то $\psi(G) = 1$, поскольку $G$ - логическое следствие формул $F_{1}, ... , F_{k}$. Полученное противоречие $\psi(G) = 1$ и $\psi(\neg G) = 1$ доказывает, что множество формул $\{  F_{1}, ... , F_{k}, \neg G \}$ невыполнимо. 
	 \par Пусть теперь множество $L$ невыполнимо. Рассмотрим интерпретацию $\phi$ такую, что $\phi (F_{1} ) = ... = \phi (F_{k}) = 1$. Поскольку $L$ невыполнимо, имеем $\phi( \neg G) = 0$. Если $\phi( \neg G) = 0$, то $\phi(G) = 1$. Следовательно из равенств $\phi (F_{1} ) = ... = \phi (F_{k}) = 1$ следует равнство  $\phi(G) = 1$. Это означает, что $G$ - логическое следствие множества формул $F_{1}, ... , F_{k}$.
	 \par Метод резолюций является методом доказательства того, что формула $G$ является логическим следствием формул $F_{1}, F_{2}, ... , F_{k}$. Исходя из \textbf{Теоремы 1} отметим, что задача о логическом следствии сводится к задаче о выполнимости. Действиетельно, формула $G$ есть логическое следствие формул  $F_{1}, F_{2}, ... , F_{k}$ тогда и только тогда, когда множество формул $ \{ F_{1}, F_{2}, ... , F_{k}, \neg G \}$ невыполнимо. Таким образом, первая особенность метода резолюций заключается в том, что он устонавливает невыполнимость множества формул. Вторая особенность метода - он оперирует не с произвольными формулами, а с \textbf{дизъюнктами}(элементарными дизъюнкциями литералов). Для удобства, на дизъюнкт мы будем смотреть, как на множество литералов, то есть не будем различать дизъюнкты, которые получаются один из другого с помощью коммутативности и ассоциативности дизъюнкции, а также идемпотентности. Также пусто дизъюнкт, не содержащий литералов, принято обозначать символом $\square$. Такой дизъюнкт ложен при любой интерпретации.
	 \par Метод резолюций в логике высказываний основан на \textbf{правиле резолюций}. Правилом резолюций в логике высказываний называется следующее правило: из дизъюнктов $A \lor B$ и $\neg A \lor C$ выводим дизъюнкт $B \lor C$. 
	 \par Например, из дизъюнктов $\neg X \lor Y \lor Z$ и $X \lor \neg Y$ вывродим дизъюнкт $Y \lor Z \lor \neg Y$. Обратим внимание на то, что в первых двух дизънктах есть еще одна пара противоположных литералов. Условимся, что можно применять правило резолюций не обязательно к самым левым литералам. Пусть $S$ - множество дизънктов. Выводом из $S$ называется последовательность дизъюнктов $D_{1}, D_{2}, ... , D_{n}$ такая, что каждый дизъюнкт этой последовательности принадлежит $S$ или следует из предыдущих по правилу резолюций.
	 \par Применение метода резолюций основано на следующем утверждении, которое называется теоремой о полноте метода резолюций.
	 \par \textbf{Теорема 2. О полноте метода резолюций.} Множество дизъюнктов логики высказываний $S$ невыполнимо тогда и только тогда, когда из $S$ выводим пустой дизъюнкт $\square$.
	 \par \textbf{\textit{Доказательство: }}Отметим, что правило резолюций сохраняет истинность. Это означает, что если $\phi (\neg X \lor F) = 1$ и $\phi (X \lor G) = 1$ для некоторой интерпретации $\phi$, то $\phi (F \lor G) = 1$.
	 \par Докажем в начале достаточность. 
	 \par Пусть из $S$ выводим пустой дизъюнкт. Предположим противное: множество $S$ выполнимо, т.е. существует интерпретация $\psi$, при которой все дизъюнкты из $S$ истинны. Выводимость пустого дизъюнкта из $S$ означает, что существует последова-
	 тельность дизъюнктов $D_{1} , ... , D_{n} = \square$, каждый дизъюнкт которой принадлежит $S$ или получается из предыдущих по правилу резолюций. Если дизъюнкт $D_{j}$ из этой последовательности принадлежит $S$, то по предположению $\psi (D_{j}) = 1$. Если же он получается из предыдущих по правилу резолюций, то также $\psi (D_{j}) = 1$, поскольку правило резолюций сохраняет истинность. При $i = n$ получаем, что $\psi (\square) = 1$. Противоречие показывает, что предположение о выполнимости множества $S$ – ложное предположение. Следовательно, $S$ невыполнимо. Достаточность доказана.
	 \par Докажем необходимость. Доказательство проведем индукцией по следующему параметру $d(s)$: это сумма числа вхождений литералов в дизъюнкты из $S$ минус число дизъюнктов.
	 \par Пусть множество дизъюнктов $S$ невыполнимо. Если пустой дизъюнкт принадлежит $S$, то он выводим из $S$ (вывод в этом случае состоит из одного пустого дизъюнкта) и необходимость теоремы доказана. Будем считать в силу этого, что $\square \notin S$. При этом предположении каждый дизъюнкт содержит хотя бы один литерал и поэтому $d(S) \geq 1$.
	 \par \textit{База индукции:} $d(S) \geq 1$. Если $d(S) = 1$, то все дизъюнкты состоят из одного литерала. Поскольку множество $S$ невыполнимо, то в нем должна найтись пара противоположных литералов $X$ и $\neg X$. В таком случае пустой дизъюнкт выводим из $S$, соответствующий вывод содержит три дизъюнкта: $X, \neg X, \square$.
	 \par \textit{Шаг индукции:} $d(S) > 1$. Предположим, что для любого множества дизъюнктов $Т$ такого, что $d(Т)<d(S)$ необходимость теоремы доказана. Пусть $S = \{D_{1}, D_{2}, ... , D_{k-1}, D_{k}  \}$.
	 \par Так как $d(S)>1$, то в $S$ существует хотя бы один неодноэлементный дизъюнкт. Будем считать, что это дизъюнкт $D_{k}$ , т.е. $D_{k} = L \lor D_{k}^\prime$ , где $L$ – литерал и $D_{k} \neq \square $. Наряду с множеством дизъюнктов $S$ рассмотрим еще два множества дизъюнктов:
	 \[
	 S_{1} = \{D_{1}, D_{2}, ... , D_{k-1}, L\}
	 \]
	 \[
	 S_{2} = \{D_{1}, D_{2}, ... , D_{k-1}, D_{k}^\prime \}
	 \]
	 \par Ясно, что $S_{1}$ и $S_{2}$ невыполнимы и что $d(S_{1})<d(S)$ и $d(S_{2}) < d(S)$. По предположению индукции из $S_{1} \text{ и } S_{2}$ выводим пустой дизъюнкт. Пусть $A_{1}, A_{2}, ... , A_{i}, ... , A_{l-1}, A_{l} = \square$ - вывод пустого дизъюнкта из $S_{1}$ и $B_{1}, B_{2}, ... , B_{j}, ... , B_{m-1}, B_{m} = \square$ - вывод пустого дизъюнкта из $S_{2}$. Если в первом выводе не содержится дизъюнкта $L$, то эта последовательность дизъюнктов будет выводом из $S$ и необходимость теоремы доказана. Будем считать, что $L$ содержится в первом выводе, пусть $A_{i} = L$. Аналогично предполагаем, что $B_{j} = D_{k}^\prime$. 
	 \par Если дизъюнкт $E$ получается из дизъюнктов $E_{1}$ и $E_{2}$ по правилу резолюций, то будем говорить, что $E$ непосредственно зависит от $E_{1}$ и от $E_{2}$. Транзитивное замыкание отношения непосредственной зависимости назовем отношением зависимости.(Другими словами, $E$ зависит от $E^\prime$ , если существуют дизъюнкты $E_{1} , … , E_{n}$ такие, что $E = E_{1} , E_{n} = E^\prime$ и $E_{1}$ непосредственно зависит от $E_{2}$ , $E_{2}$ непосредственно зависит от $E_{3} , … , E_{n-1}$ непосредственно зависит от $E_{n}$). Преобразуем второй вывод следующим образом: к дизъюнкту $B_{j}$ и всем дизъюнктам, которые от него зависят, добавим литерал $L$. Новая последовательность (1) дизъюнктов $B_{1}, B_{2}, ... , B_{j}^\prime =  D_{k}^\prime \lor L, B_{j+1}^\prime , ... , B_{m}^\prime $ будет выводом из $S$. Если дизъюнкт $B_{m}$ не зависит от $B_{j}$ , то $B_{m}^\prime = \square$. Это означает, что из $S$ выводим пустой дизъюнкт, что и требовалось доказать. Предположим, что $B_{m}$ зависит от $B_{j}$ . Тогда $B_{m}^\prime = L$. Преобразуем теперь первый вывод: на место дизъюнкта $A_{i}$ (равного $L$) в этой последовательности подставим последовательность (1). Получим последовательность $A_{1}, ... , A_{i-1}, B_{1}, ... , B_{j}^\prime , B_{j+1}^\prime, ... , B_{m}^\prime = L , A_{i+1}, ... , A_{l} = \square$. Эта последовательность является выводом пустого дизъюнкта из множества дизъюнктов S. Следовательно, если множество $S$ невыполнимо, то из $S$ выводим пустой дизъюнкт $\square$. 
	  \begin{center}
	 	\subsection{Применение метода резолюций в логике высказываний}
	 \end{center} 
	 \par Для доказательства того, что формула $G$ является логическим следствием множества формул $F_{1}, ... , F_{k}$, метод резолюций применяется следующим образом. 
	 \par Сначала составляется множество формул $T = \{F_{1} , …, F_{k} ,\neg G\}$. Затем каждая из этих формул приводится к конъюнктивной нормальной форме и в полученных формулах зачеркиваются знаки конъюнкции. Получается множество дизъюнктов $S$. И, наконец, ищется вывод пустого дизъюнкта из $S$. Если пустой дизъюнкт выводим из $S$, то формула $G$ является логическим следствием формул $F_{1}, ... , F_{k}$ . Если из $S$ нельзя вывести $\square$, то $G$ не является логическим следствием формул $F_{1}, ... , F_{k}$.
	 \par Приведем \textbf{пример} использования метода резолюций. Покажем, что формула $G = Z$ является логическим следствием формул $F_{1} = \neg X \lor Y \rightarrow X \land Z, F_{2} = \neg Y \rightarrow Z$. Сформируем множество формул $T = \{F_{1}, F_{2}, \neg G \}$. Приведем формулы $F_{1}$ и $F_{2}$ к КНФ(фомрула $\neg G$ уже находится в КНФ). Получим: $F_{1} = X \land (\neg Y \lor Z), F_{2} = Y \lor Z$. 
	 \par  Тогда множество дизъюнктов $S = \{X, \neg Y \lor Z, Y \lor Z, \neg Z \}$. Из множества $S$ легко выводится пустой дизъюнкт: $\neg Y \lor Z, \neg Z, \neg Y, Y \lor Z, Y, \square$.
	 \par Следовательно, формула $G$ является логическим следствием формул $F_{1}, F_{2}$.
	 
	 \newpage
	 \begin{center}
	 	\section*{ГЛАВА 2. ПРАКТИЧЕСКАЯ ЧАСТЬ}
	 	\addcontentsline{toc}{section}{Глава 2. Практическая часть}
	 \end{center}
	 \setcounter{section}{2}
	 \setcounter{subsection}{0}
	 \begin{center}
	 	\subsection{Введение}
	 \end{center} 
	 \par Для реализации метода резолюций в логике высказыаний была написана программа на языке программирования C++ с использованием фреймворка Qt. Для данной программы были поставлены следующие функциональные требования:
	 \begin{enumerate}
	 	\item Ввод данных:
	 	\begin{itemize}
	 		\item Программа должна позволять пользователю вводить логические выражения в корректном формате.
	 	\end{itemize}
	 	\item Обработка данных:
	 	\begin{itemize}
	 		\item Реализация метода резолюций для логики высказываний.
	 		\item Преобразование входных логических выражений в конъюнктивную нормальную форму.
	 		\item Генерация новых дизъюнктов посредством правила резолюций до получения пустого дизъюнкта или до невозможности дальнейшего разрешения.
	 	\end{itemize}
	 	\item Вывод данных:
	 	\begin{itemize}
	 		\item Отображение результатов выполнения метода резолюций.
	 		\item Отображения множества дизъюнктов $S$ и вывода из него.
	 		\item Сообщение пользователю о том, является ли введенная теорема логическим следствием введенных формул.
	 	\end{itemize}
	 	\item Пользовательский интерфейс:
	 	\begin{itemize}
	 		\item Предоставление графического интерфейса для ввода данных и отображения результатов.
	 		\item Кнопки для запуска процесса резолюции и удаления введенных данных.
	 	\end{itemize}
	 \end{enumerate}
	 \par Чтобы знаки логических операций отображались но всех устройствах одинаково и без ошибок, в рамках данного приложения для логических операций введены следующие эквивалентные символы:
	 \begin{itemize}
	 	\item Операция $\neg$ обозначается символом <<!>>.
	 	\item Операция $\lor$ обозначается символом <<+>>.
	 	\item Операция $\land$ обозначается символом <<*>>.
	 	\item Операция $\rightarrow$ обозначается символом <<\text{->}>>.
	 	\item Операция $\leftrightarrow$ обозначается символом <<==>>.
	 \end{itemize}
	 \begin{center}
	 	\subsection{Реализация}
	 \end{center} 
	 \par Программа состоит из трех основных классов: 
	 \begin{itemize}
	 	\item \textbf{MainWindow}
	 	\item \textbf{Formula}
	 	\item \textbf{Resolution}
	 \end{itemize}
	 \par Каждый класс выполняет определенную роль в реализации функционала приложения. На рисунке \ref{fig:diag} показана диграмма классов[6]:
	 \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.9\textwidth]{img/diag}
	 	\caption{Диаграмма классов}
	 	\label{fig:diag}
	 \end{figure}\\
	 \begin{enumerate}
	 	\item \textbf{MainWindow}\\
	 	Данный класс отвечает за основное окно приложения. Он предоставляет пользователю интерфейс для добавления литералов и управления диалоговыми окнами для ввода формул и проверки теоремы методом резолюций. Так же данный класс обрабатывает пользовательские события, такие как нажатие кнопок, ввод формулы и запуск процесса резолюции.
	 	\item \textbf{Formula}\\
	 	Класс Formula отвечает за ввод логических функций. Он предоставляет диалоговое окно, в котором пользователь может ввести логическое выражение. Также важнейшей функцией этого класса является проверка на корректность введенной формулы. Введенная формула передается в основной класс для дальнейшей обработки.
	 	\item \textbf{Resolution}\\
	 	Данный класс реализует метод резолюций для проверки теоремы. Он отвечает за выполнение следующих действий:
	 	\begin{itemize}
	 		\item Приведение каждой формулы из множества допущений к КНФ.
	 		\item Строится новая формула - отрицание введенной теоремы, которая так же приводится к КНФ.
	 		\item Из всех полученных КНФ удалением знака <<*>> составляется множество дизъюнктов S.
	 		\item Ищется вывод из множества S.
	 		\item Отображение результатов выполнения алгоритма пользователю.
	 	\end{itemize}
	 \end{enumerate}
	 \par Классы взаимодействуют между собой следующим образом: при запуске программы создается объект класса MainWindow, отображающий основное окно. При нажатии кнопки <<Задать гипотезу>> или <<Добавить допущение>> вызывается диалоговое окно Formula для ввода формулы. При нажатии кнопки <<Сохранить>> в этом диалоговом окне введенная формула проверяется на корректность и сохраняется в классе MainWindow. Окно Resolution с результатами метода резолюций вызывается при нажатии кнопки <<Проверить гипотезу>> на основном окне приложения.
	 \par Рассмотрим структуру каждого класса отдельно.
	 \newpage
	 \begin{center}
	 	\subsection{Класс MainWindow}
	 \end{center} 
	 На рисунке \ref{fig:mainwindow} изображен интерфейс основного окна.
	 \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.8\textwidth]{img/mainwindow}
	 	\caption{Основное окно приложения}
	 	\label{fig:mainwindow}
	 \end{figure}
	 \par Рассмотрим основные поля класса:
	 \begin{itemize}
	 	\item \texttt{QVector<QString> literals} - поле содержащее массив литералов (латинские буквы в верхнем регистре <<A-Z>>).
	 	\item \texttt{QVector<QString> formulas} - массив введенных формул (допущений).
	 	\item \texttt{QString theorem} - введенная теорема.
	 	\item \texttt{QString lastButton} - вспомогательная переменная, содержащая название последней нажатой кнопки. Необходима, для корректного использования одного класса Formula для сохранения формул отдельно от теоремы.
	 	\item \texttt{formula* addFormula} - диалоговое окно добавления формулы.
	 	\item \texttt{resolution* res} - диалоговое окно для применения метода резолюций и отображения результата.
	 	\item \texttt{int count} - количество добавленных литералов.
	 \end{itemize} 
	 \par Так как взаимодействие пользователя с программой реализовано посредством нажатия на кнопки, необходимо соединить событие нажатия определенной кнопки с соответствующим слотом. Для этого была написана функция \texttt{void connectAllButtons()}.
	 \par Для добавления литерала написан слот \texttt{void addLiteral()} который добавляет следующую букву латинского алфавита в список литералов. Аналогично для удаления последнего добавленного литерала написан слот \texttt{void deleteLiteral()}.
	 \par Для вызова дилогового окна добавления формулы написан метод \texttt{showAddFormula}. Данное окно может быть закрыто с сохранением введенной формулы (если она корректна) при помощи слота \texttt{void saveFormula()} или без сохранения при помощи метода \texttt{void closeAddFormula()}. Удаление последней добавленной формулы реализовано слотом \texttt{void deleteFormula()}, а удаление теоремы слотом \texttt{void deleteFormula()}. Все изменения отображаются на главном окне с помощью методов \texttt{void updateList()}, \texttt{void updateFormulas()}, \texttt{void updateTheorem()} для обновления списка переменных, списка формул и теоремы соответственно.
	 \par Для получения результата метода резолюций вызывается метод \texttt{void\\ showResolution()}. Диалоговое окно с результатами закрывается слотом \texttt{void\\ closeResolution()}. 
	 \par В рамках данного отчета рассматривать подробно реализации всех функций данного класса не будем, так как они обеспечивают пользовательский интерфейс и по сути не имеют отношения к методу резолюций. 
	 \newpage
	  \begin{center}
	 	\subsection{Класс Formula}
	 \end{center} 
	 \par На рисунке \ref{fig:formula} изображено диалоговое окно для ввода формулы.
	 \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.6\textwidth]{img/formula}
	 	\caption{Диалоговое окно ввода формулы}
	 	\label{fig:formula}
	 \end{figure}
	 Рассмотрим основные поля класса:
	 \begin{itemize}
	 	\item \texttt{int row, column}. Кнопки для ввода символов расположены в сетку по 4 кнопки в ряд. Данные переменные нужны для корректоного отображения кнопок.
	 	\item \texttt{QVector<QString> buttons} - массив названий кнопок операций.
	 	\item \texttt{QVector<QString> l} - массив названий кнопок литералов. Он заполняется массивом литералов из класса MainWindow при вызове диалогового окна.
	 	\item \texttt{int braketsCount} - счетчик введенных скобок (<<()>> и <<)>>). Нужен для проверки корректности введенной формулы.
	 \end{itemize}
	 \par Рассмотрим основные методы и слоты этого класса. \texttt{void clearLine()} - метод для очистки введенной строки. Вызывается при отображении диалогового окна.
	 \par \texttt{QString getFormula()} - геттер для введенной формулы. С его помощью формула добавляется в массив формул в классе MainWindow. 
	 \par При добавлении литералов, необходимо обновить кнопки для ввода. Для этого написан метод \texttt{void updateButtons()}, а метод \texttt{void connectAllButtons()} соединяет все кнопки с соответствующими слотами.
	 \par Проверка корректности ввода формулы осуществляется следующим образом. Для этого написан метод \texttt{bool check()} который возвращает значение \texttt{true} только, если в введнной строке содержиться хотя бы 1 литерал, если нет двух литералов подряд без операции между ними и количество открытых скобок равно количеству закрытых. Также, так как есть возможность удалять введенный символ при помощи слота \texttt{void backspace()}, соответственно возможно стереть часть операции <<==>> или <<\textbf{->}>>. Функция также проверяет не стерта ли часть этих операций. Для ограничения ввода написан соответствующий слот \texttt{void onButtonClicked(const QString \& text)}, который принимает текст нажатой кнопки и проверяет не введена ли вторая операция подряд. 
	 \par  Для сохранения фомрмулы предназначен слот \texttt{void save()}, который посылает сигнал сохранения \texttt{void saveSignal()} и закрывает диалоговое окно. Аналогично для закрытия окна без сохранения реализован слот \texttt{void close()}. 
	 \par Аналогично классу MainWindow класс Formula не имеет отношения к реализации метода резолюций, поэтому не будем рассматривать подробно реализацию каждого метода. 
	  \begin{center}
	 	\subsection{Класс Resolution}
	 \end{center} 
	 \par Данный класс отвечает за приминение метода резолюций и вывод результата. На рисунке \ref{fig:resolution} изображен интерфейс диалогового окна.
	 \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.49\textwidth]{img/resolution}
	 	\caption{Диалоговое окно ввода формулы}
	 	\label{fig:resolution}
	 \end{figure}\\
	 \par Рассмотрим поля класса Resolution:
	 \begin{itemize}
	 	\item \texttt{QVector<QString> literals} - массив литералов, который заполняется массивом из основного класса MainWindow.
	 	\item \texttt{QVector<QString> formulas} - аналогичный массив формул (допущений).
	 	\item \texttt{QStringList S} - массив дизъюнктов. 
	 	\item \texttt{QString theorem} - введенная теорема.
	 \end{itemize}
	 \par Приминение метода резолюций можно разделить на следующие этапы:
	 \begin{enumerate}
	 	\item Приведение формул к КНФ.
	 	\item Отрицание теоремы и приведение полученной формулы к КНФ.
	 	\item Составление множества дизъюнктов S.
	 	\item Нахождение вывода из множества S при помощи правила резолюций.
	 \end{enumerate}
	 \par При реализации программы одним из самых сложных этапов стало приведение произвольной формулы к КНФ. Алгоритм приведения формулы к КНФ[3]:
	 \begin{enumerate}
	 	\item Избавиться от операций эквивалетности <<==>> и импликации <<\text{->}>>, заменив их конъюнкцией, дизъюнкцией и отрицанием. Для этого надо использовать следующие формулы: $A \rightarrow B = \neg A \lor B$ и $A \leftrightarrow B = (\neg A \lor B) \land (A \lor \neg B)$.
	 	\item Заменить знаки отрицания, относящиеся к выражению, знакакми отрицания относящимися к литералам. Для этого надо использовать правила Де Моргана:\\ $\neg (A \lor B) = \neg A \land \neg B$ и $\neg (A \land B) = \neg A \lor \neg B$
	 	\item Избавиться от двойного отрицания.
	 	\item Применить, если нужно, к операциям конъюнкции и дизъюнкции свойства дистрибутивности.
	 \end{enumerate}
	 Отметим, что для метода резолюций не принципиальна минимальность КНФ, поэтому к полученному выражению можно не применять правила поглащения.
	 \par Для избавления от операции эквивалентности <<==>> был написан метод \texttt{void}\\ \texttt{removeEq(QString\& str)}. Данный метод применятется пока в строке с формулой содержится <<==>>. Он определяет операнды справа и слева от знака операции (это может быть просто литерал, отрицание литерала,  скобка или отрицание скобки)[5]. Затем составляется новая строка \texttt{newStr} с выражением с использованием этих операндов, часть старой формулы меняется на \texttt{newStr}.
	 \par Аналогичным способом реализован метод для избавления от импликации \texttt{void \\ removeImplication(QString\& str)}. Он также определяет левый и правый опренд и заменяет импликацию эквивалентным выражением.
	 \par Для избавления от отрицания выражений написан метод \texttt{void removeNotBrackets \\(QString\& str)}. Он работает следующим образом. Пока в строке формулы содержится <<!(>> (отрицание выражения) перебираем символы строки, если этот символ - отрицание, то возможны два варианта: это либо отрицание литерала, тогда ничего делать не надо, или это отрицание выражения. В таком случае определяется подстрока, заключенная между скобками. Если эта подстрока содержит операции, то применяются правила Де Моргана, если же операций нет, то это лишние скобки и их можно просто удалить.
	 \par Двойное отрицание удаляется с помощью метода \texttt{void removeDoubleNot(QString\& str)} он использует регулярное выражение и заменяет все вхождения <<!!>> на пустую строку.
	 \par Последний шаг в приведении к КНФ - это раскрытие скобок и применение закона дистрибутивности для конъюнкции. Данные действия выполняет метод \texttt{void \\replaceParentheses (QString\& str)}. Он пока строка изменяется раскрывает скобки следую следующим правилам: если в скобках содержится только умножение, то скобки лишние и их можно удалить, если в скобках только плюсы, то скобки не удаляются, так как подстрока содержащаяся в этих скобках является дизъюнктом. Если же внутри скобок есть как сложение, так и умножение, то применяется закон дистрибутивности и эти скобки заменяются на произведение скобок, содержащих только сложение (что и является КНФ).
	 \par Таким образом описанные выше методы приводят строку к КНФ. Для более удобного приведения написана функция \texttt{void ToCNF(QString\& str)}. 
	 \begin{cppcode}[caption = Метод void ToCNF(QString\& str).]
	 	void resolution::ToCNF(QString &str)
	 	{
	 		removeEq(str);
	 		removeImplication(str);
	 		removeNotBrackets(str);
	 		removeDoubleNot(str);
	 		replaceParentheses(str);
	 		QStringList res;
	 		QStringList tmp = str.split('*');
	 		for (QString& s : tmp) {
	 			removeBrackets(s);
	 			if(hasNoContradiction(s)){
	 				removeDuplicateLiterals(s);
	 				res.append(s);
	 			}
	 		}
	 		str = res.join('*');
	 	}
	 \end{cppcode}
	 \par После вызова описанных выше методов получаем формулу в КНФ, но ее слагаемые могут иметь лишние скобки, поэтому просто можно удалить все скобки методом \texttt{void removeNotBrackets(QString\& str)}. Также строка разбивается на подстроки - дизъюнкты, и с помощью метода \texttt{bool hasNoContradiction(const QString \&formula)} происходит проверка, содержит ли дизъюнкт литерал и его отрицание. Если содержит, то этот множитель можно удалить так как он тождественно равен единице.
	 \par В дальнейшем для реализации правила резолюций нам понадобится удалять повторяющиеся литералы с дизъюнкте. Для этого написан метод \texttt{void\\ removeDuplicateLiterals (QString \&formula)}. 
	 \par После приведения формул к КНФ, необходимо составить множество дизъюнктов S. Для этого написан метод  \texttt{void formulaToS (const QString\& str)} который принимает в качестве параметра строку с формулой в КНФ и разделяет ее по символу <<*>>. Полученные дизъюнкты добавляются в массив дизъюнктов S. 
	 \par Только теперь, когда составлено множество исходных дизъюнктов S. Можно приступить к применению правила резолюций для вывода новых дизъюнктов. Эту функцию выполняет метод \texttt{void applyResolution()}. Он работает по следующему принципу: пока есть новый добавленный дизъюнкт перебираются все возможные пары дизъюнктов (\texttt{disjunct1} и \texttt{disjunct1}) из множества S и, если в них есть противоположные слагаемые, то создается новый массив слагаемых \texttt{QSet<QString> resolven} в него записываются все слагаемые из обоих дизъюнктов, кроме противоположных. Далее, если получилась пустая резольвента, то в S добавляется пустой дизъюнкт, если же резольвента не пустая и не содержит противоположных переменных (иначе она равна единице) то она добавляется в множество S.
	 \begin{cppcode}[caption = Метод void applyResolution().]
	 	void resolution::applyResolution()
	 	{
	 		bool newDisjunctAdded = true;
	 		while (newDisjunctAdded) {
	 			newDisjunctAdded = false;
	 			QStringList newDisjuncts;
	 			for (int i = 0; i < S.size(); ++i) {
	 				for (int j = i + 1; j < S.size(); ++j) {
	 					QSet<QString> disjunct1 = splitDisjunct(S[i]);//
	 					QSet<QString> disjunct2 = splitDisjunct(S[j]);
	 					bool foundContradiction = false;
	 					QString literalToRemove;
	 					QString negatedLiteralToRemove;
	 					for (const QString& literal : disjunct1) {
	 						QString negatedLiteral = (literal.startsWith("!") ? literal.at(1) : "!" + literal);
	 						if (disjunct2.contains(negatedLiteral)) {
	 							foundContradiction = true;
	 							literalToRemove = literal;
	 							negatedLiteralToRemove = negatedLiteral;
	 							break;
	 						}
	 					}
	 					if (foundContradiction) {//
	 						QSet<QString> resolvent = disjunct1;
	 						resolvent.unite(disjunct2);
	 						resolvent.remove(literalToRemove);
	 						resolvent.remove(negatedLiteralToRemove);
	 						if (resolvent.isEmpty()) {
	 							if (!S.contains("0")) {
	 								newDisjuncts.append("0");
	 								newDisjunctAdded = true;
	 							}
	 						} else {
	 							QString resolventStr = QStringList(resolvent.toList()).join("+");
	 							removeDuplicateLiterals(resolventStr);
	 							if (!S.contains(resolventStr) && hasNoContradiction(resolventStr)) {
	 								newDisjuncts.append(resolventStr);
	 								newDisjunctAdded = true;
	 							}
	 						}
	 					}
	 				}
	 			}
	 			newDisjuncts.removeDuplicates();
	 			S.append(newDisjuncts);
	 		}
	 	}
	 \end{cppcode}
	 \par Вывод результата производится с помощью метода \texttt{void printResult(QString t)}. Если множество S после применения правила резолюций содержит пустой дизъюнкт <<0>>, то пользователю сообщается, что исходная теорема является логическим следствием введенных теорем, в противном случае теорема не является логическим следствием.
	  \newpage
	 
 	 \section*{\centering ГЛАВА 3. ТЕСТИРОВАНИЕ}
 	 \addcontentsline{toc}{section}{Глава 3. Тестирование}
	 \setcounter{section}{3}
	 \setcounter{subsection}{0}
	 \begin{center}
	 	\subsection{Введение}
	 \end{center} 
	 \par Для проверки работоспособности программы были разработаны следующие сценарии тестирования:
	 \begin{enumerate}
	 	 \item Ввод некорректоной формулы.
	 	 \item Ввод корректных формул допущений, и попытка выполнения метода резолюций при отсутствии гипотезы теоремы.
	 	 \item Ввод гипотезы теоремы, и выполнение метода резолюций при пустом множестве допущений. 
	 	 \item Попытка ввода нескольких теорем.
	 	 \item Проверка верной теоремы методом резолюций.
	 	 \item Проверка ложной теоремы методом резолюций.
	 	 \item Ввод нескольких одинаковых допущений.
	 \end{enumerate}
	 \begin{center}
	 	\subsection{Сценарий тестирования 1}
	 \end{center} 
	 \par При попытке сохранить формулу на рисунке \ref{fig:test1.1} пользователю выдается следующее сообщение (рисунок \ref{fig:test1.2} )
	 \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.50\textwidth]{img/test1.1}
	 	\caption{Ввод некорректной формулы}
	 	\label{fig:test1.1}
	 \end{figure}\\
	 \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.50\textwidth]{img/test1.2}
	 	\caption{Ошибка ввода неправильной формулы}
	 	\label{fig:test1.2}
	 \end{figure}\\
	 \par Также отметим, что при попытке ввода двух операций подряд из множества \texttt{+, *, ==, ->}.
	  \begin{center}
	 	\subsection{Сценарий тестирования 2}
	 \end{center} 
	 \par Пусть введены верные допущения, но не введена гипотеза, как показано на рисунке \ref{fig:test2.1}.
	 \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.47\textwidth]{img/test2.1}
	 	\caption{Отсутствие гипотезы теоремы}
	 	\label{fig:test2.1}
	 \end{figure}
	 
	 В таком случае при попытке проверить гипотезу пользователь получит  сообщение, показанное на рисунке  \ref{fig:test2.2}.
	 \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.50\textwidth]{img/test2.2}
	 	\caption{Ошибка}
	 	\label{fig:test2.2}
	 \end{figure}
	 \newpage
	 
	  \begin{center}
	 	\subsection{Сценарий тестирования 3}
	 \end{center} 
	 \par Пусть введена только гипотеза, а множество допущений не содержит формул, как показано на рисунке \ref{fig:test3.1}.
	 \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.50\textwidth]{img/test3.1}
	 	\caption{Отсутствие допущений}
	 	\label{fig:test3.1}
	 \end{figure}
	 \par В таком случае, так как из пустого множества формул ничего не следует, мы должны получить вывод о том, что введенная гипотеза не является логическим следствием пустого множества формул. Вывод приложения показан на рисунке \ref{fig:test3.2}.
	  \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.50\textwidth]{img/test3.2}
	 	\caption{Ошибочная гипотеза}
	 	\label{fig:test3.2}
	 \end{figure}
	 \newpage
	 \begin{center}
	 	\subsection{Сценарий тестирования 4}
	 \end{center} 
	 \par Пусть гипотеза теоремы уже введена (как показано на рисунке \ref{fig:test3.1}) и пользователь пробует ввести еще одну теорему. 
	 \par В таком случае пользователь увидет следующую ошибку (рисунок \ref{fig:test4.1}).
	 \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.50\textwidth]{img/test4.1}
	 	\caption{Попытка ввести несколько теорем}
	 	\label{fig:test4.1}
	 \end{figure}
	 
	 \begin{center}
	 	\subsection{Сценарий тестирования 5}
	 \end{center} 
	 \par Пусть заданы формулы и теорема, такие как показано на рисунке \ref{fig:test5.1}.
	 \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.50\textwidth]{img/test5.1}
	 	\caption{Проверка верной теоремы}
	 	\label{fig:test5.1}
	 \end{figure}
	 \newpage
	 \par Рассмотрим результат метода резолюций (рисунок \ref{fig:test5.2}).
	 \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.50\textwidth]{img/test5.2}
	 	\caption{Положительный результат}
	 	\label{fig:test5.2}
	 \end{figure}\\
	 \par Рассмотрим получившееся множество S. Первые два дизъюнкта получились из КНФ первой формулы $A == !B = (!A + !B) * (A + !!B) = (!A + !B) * (A + B)$. Третий дизъюнкт получили из второй формулы (она уже находится в КНФ). Четверый дизъюнкт - отрицание теоремы. Применив правило резолюций к третьему и четвертому дизъюнктам ($A+!B$ и $!A$) получим пятый дизъюнкт ($!B$). Аналогично из пятого и второго дизъюнктов ($!B$ и $A+B$) получим шестой $A$. Из второго и четвертого дизъюнктов ($A+B$ и $!A$) получим седьмой $B$. Пустой дизъюнкт можно получить из четвертого и шестого или из седьмого и пятого. Таким образом, формула $A$ действительно является логическим следствием формул\\ $A==!B$ и $A+!B$.
	 
	 \begin{center}
	 	\subsection{Сценарий тестирования 6}
	 \end{center} 
	 \par Пусть введены формулы, как показано на рисунке \ref{fig:test6.1}.
	 \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.50\textwidth]{img/test6.1}
	 	\caption{Проверка ложной теоремы}
	 	\label{fig:test6.1}
	 \end{figure}
	 
	 \par Рассмотрим результат метода резолюций (рисунок \ref{fig:test6.2}).
	\newpage
	 \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.50\textwidth]{img/test6.2}
	 	\caption{Отрицательный результат}
	 	\label{fig:test6.2}
	 \end{figure}\\
	 \par Рассмотрим множество дизъюнктов S. Первые два дизъюнкта получены из КНФ введенной формулы $A*(B==(A+B))=A*(!B+A+B)*(B+!A)*(B+!B)=A*(B+!A)$. Третий дизъюнкт получается из КНФ отрицания теоремы $!(B*C)=!B+!C$. Далее из первого и второго дизъюнктов выводится четвертый $B$. Из второго $B+!A$ и третьего $!B+!C$ выводится пятый. Из первого и пятого выводится $!C$. Дальнейший вывод невозможен, а множество S не содержит пустого дизъюнкта, следовательно $B*C$ не следует из $A*(B == (A+B))$.
	 \begin{center}
	 	\subsection{Сценарий тестирования 7}
	 \end{center} 
	 \par Пусть пользователь уже ввел формулу $(B \rightarrow !A)==(C+(D \rightarrow !B))$, как показано на рисунке \ref{fig:test7.1}, и попробует ввести ее еще раз. 
	  \begin{figure}[h!]
	 	\centering
	 	\includegraphics[width=0.50\textwidth]{img/test7.1}
	 	\caption{Ввод формулы}
	 	\label{fig:test7.1}
	 \end{figure}
	  \newpage
	 В таком случае пользователь увидит следующие сообщение:
	  \begin{figure}[h!]
	  	\centering
	  	\includegraphics[width=0.50\textwidth]{img/test7.2}
	  	\caption{Повторный ввод формулы}
	  	\label{fig:test7.2}
	  \end{figure}
	  \par Проверим, какие дизъюнкты получились из введенной формулы (рисунок \ref{fig:test7.3}):
	  \begin{figure}[h!]
	  	\centering
	  	\includegraphics[width=0.50\textwidth]{img/test7.3}
	  	\caption{Результат}
	  	\label{fig:test7.3}
	  \end{figure}
	  \par Приведем формулу $(B \rightarrow !A)==(C+(D \rightarrow !B))$ к КНФ:  $(B \rightarrow !A)==(C+(D \rightarrow \\ \rightarrow !B)) = (!B+!A) == (C+!D+!B) = (C+!D+!B+A)*(C+!D+!B+B)*(!B+!A+!C)* \\ *(!B+!A+D+B)*(!B+!A+D) = (C+!D+!B+A)*(!B+!A+!C)*(!B+!A+D)$. Видим, что первые три дизъюнкта из множества S на рисунке  \ref{fig:test7.3} соответствуют КНФ данной формулы. Четвертый дизъюнкт - КНФ отрицания введенной теоремы, а дальше идет вывод из этих дизъюнктов.
	 \newpage
	  \begin{center}
	 	\subsection{Итоги тестирования}
	 \end{center} 
	 \par Результаты тестирования показали, что программа успешно выполняет все заявленные функции. Все тесты были пройдены успешно, что подтверждает корректность работы алгоритмов.
	 \newpage
	 \begin{center}
	 	\section*{ЗАКЛЮЧЕНИЕ}
	 	\addcontentsline{toc}{section}{Заключение}
	 \end{center}
	 \par В ходе выполнения данной работы был изучен метод резолюций в логике высказываний, который является фундаментальным инструментом для автоматического доказательства теорем и логического вывода. Были исследованы теоретические основы метода резолюций, его алгоритмы и примеры применения.
	 \par В результате проведенного исследования была разработана программа, успешно реализующая метод резолюций. Программа состоит из трех основных классов:\\ \texttt{MainWindow}, \texttt{Formula} и \texttt{Resolution}. Класс \texttt{MainWindow} обеспечивает пользовательский интерфейс, позволяющий пользователю вводить логические формулы и проверять теоремы методом резолюций. Классы \texttt{Formula} и \texttt{Resolution} реализуют основные алгоритмы работы с логическими формулами и выполнение резолюций соответственно.
	 \par Программа прошла тестирования различными сценариями. Результаты тестирования подтвердили корректность работы программы.
	  \newpage
	 \begin{center}
	 	\section*{СПИСОК ИСТОЧНИКОВ}
	 	\addcontentsline{toc}{section}{Список источников}
	 \end{center}
	 \begin{enumerate}
	 	\item Замятин, А. П. Математическая логика и теория алгоритмов / А. П. Замятин - Екатеренбург, 2008. - 274 с.
	 	\item Чень, Ч. Математическая логика и автоматическое доказательство теорем / Ч. Чень, Р. Ли; пер. с англ. Г. В. Давыдов, Г. Е. Минц, А. В. Сочилина - Москва, 1983. - 360 с.
	 	\item Конъюнктивная нормальная форма - URL: \url{https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%8A%D1%8E%D0%BD%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0}(Дата обращения: 06.07.2024)
	 	\item Правило резолюций - URL: \url{https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE_%D1%80%D0%B5%D0%B7%D0%BE%D0%BB%D1%8E%D1%86%D0%B8%D0%B9} (Дата обращения: 01.07.2024)
	 	\item Разбор арифметического(и не только) выражения. Классические алгоритмы. - URL - \url{https://algolist.ru/syntax/parsear.php} (Дата обращения: 30.06.2024)
		\item Создание UML-диаграмм - URL - \url{https://app.diagrams.net/} (Дата обращения: 03.07.2024)
		\item GitHub - URL - \url{https://github.com/Vadikkkkk/A-resolution-technique/tree/release} (Дата обращения: 08.07.2024)
	 \end{enumerate}
	 \newpage 
	 \titleformat*{\section}{\Large\raggedleft\textbf}
	 \section*{\textbf{Приложение}}
	 \addcontentsline{toc}{section}{Приложение. Код разработанной программы}
	 \begin{center}
	 	\textbf{Файл MainWindow.h}
	 \end{center}
	 \begin{cppcode}[caption = Файл MainWindow.h]
	 	#ifndef MAINWINDOW_H
	 	#define MAINWINDOW_H
	 	
	 	#include <QMainWindow>
	 	#include <QSet>
	 	#include <QMessageBox>
	 	
	 	#include "formula.h"
	 	#include "resolution.h"
	 	
	 	
	 	QT_BEGIN_NAMESPACE
	 	namespace Ui { class MainWindow; }
	 	QT_END_NAMESPACE
	 	
	 	class MainWindow : public QMainWindow
	 	{
	 		Q_OBJECT
	 		
	 		public:
	 		MainWindow(QWidget *parent = nullptr);
	 		~MainWindow();
	 		
	 		private:
	 		Ui::MainWindow* ui;
	 		
	 		int count;//
	 		QVector<QString> literals;//
	 		QVector<QString> formulas;//
	 		QString theorem;//
	 		
	 		QString lastButton;
	 		
	 		formula* addFormula;
	 		resolution* res;
	 		
	 		void updateList();//
	 		void updateFormulas();//
	 		void updateTheorem();//
	 		
	 		void connectAllButtons();
	 		
	 		
	 		public slots:
	 		void addLiteral();
	 		void deleteLiteral();
	 		
	 		void showAddFormula();
	 		void closeAddFormula();
	 		
	 		void saveFormula();
	 		void deleteFormula();
	 		
	 		void deleteTheorem();
	 		
	 		void showResolution();
	 		void closeResolution();
	 		
	 	};
	 	#endif // MAINWINDOW_H
	 \end{cppcode}
	  \centering \textbf{Файл MainWindow.cpp}
	  \begin{cppcode}[caption = Файл MainWindow.cpp]
	  	#include "mainwindow.h"
	  	#include "ui_mainwindow.h"
	  	
	  	
	  	MainWindow::MainWindow(QWidget *parent)
	  	: QMainWindow(parent)
	  	, ui(new Ui::MainWindow), count(0)
	  	{
	  		ui->setupUi(this);
	  		
	  		addFormula = new formula;
	  		res = new resolution;
	  		
	  		connectAllButtons();
	  	}
	  	
	  	MainWindow::~MainWindow()
	  	{
	  		delete ui;
	  		delete addFormula;
	  		delete res;
	  	}
	  	
	  	void MainWindow::updateList()
	  	{
	  		ui->literals->clear();
	  		for (const QString& str : literals) {
	  			ui->literals->addItem(str);
	  		}
	  	}
	  	
	  	void MainWindow::updateFormulas()
	  	{
	  		ui->formulas->clear();
	  		for (const QString& str : formulas) {
	  			ui->formulas->addItem(str);
	  		}
	  	}
	  	
	  	void MainWindow::updateTheorem()
	  	{
	  		ui->theorem->clear();
	  		ui->theorem->addItem(this->theorem);
	  	}
	  	
	  	void MainWindow::connectAllButtons()
	  	{
	  		connect(ui->add_literal, &QPushButton::clicked, this, &MainWindow::addLiteral);
	  		connect(ui->add_formula, &QPushButton::clicked, this, &MainWindow::showAddFormula);
	  		connect(ui->addTheorem,&QPushButton::clicked, this, &MainWindow::showAddFormula);
	  		
	  		connect(ui->delete_literal, &QPushButton::clicked, this, &MainWindow::deleteLiteral);
	  		connect(ui->delete_formula, &QPushButton::clicked, this, &MainWindow::deleteFormula);
	  		connect(ui->deleteTheorem, &QPushButton::clicked, this, &MainWindow::deleteTheorem);
	  		connect(ui->resolution, &QPushButton::clicked, this, &MainWindow::showResolution);
	  		
	  		connect(addFormula, &formula::closeSignal, this, &MainWindow::closeAddFormula);
	  		connect(addFormula, &formula::saveSignal, this, &MainWindow::saveFormula);
	  		
	  		connect(res, &resolution::closeSignal, this, &MainWindow::closeResolution);
	  	}
	  	
	  	void MainWindow::addLiteral()
	  	{
	  		if(count < 26){
	  			QChar letter = 'A';
	  			literals.append(QString(letter.unicode() + count));
	  			count++;
	  			updateList();
	  		}
	  		else{
	  			QMessageBox::information(this, "Ошибка!", "Слишком много литералов!");
	  		}
	  	}
	  	
	  	void MainWindow::deleteLiteral()
	  	{
	  		if(count > 0){
	  			literals.pop_back();
	  			count--;
	  			updateList();
	  		}
	  		else{
	  			QMessageBox::information(this, "Ошибка!", "Литералов нет!");
	  		}
	  	}
	  	
	  	void MainWindow::showAddFormula()
	  	{
	  		QPushButton *button = qobject_cast<QPushButton *>(sender());
	  		if (button == ui->addTheorem && theorem.isEmpty()) {
	  			lastButton = ui->addTheorem->text();
	  			setEnabled(false);
	  			addFormula->clearLine();
	  			addFormula->braketsCount = 0;
	  			addFormula->l = literals;
	  			addFormula->updateButtons();
	  			addFormula->show();
	  		}
	  		else if (button == ui->addTheorem && !theorem.isEmpty()){
	  			QMessageBox::information(this, "Ошибка!", "Гипотеза уже введена!");
	  		}
	  		else if (button == ui->add_formula) {
	  			lastButton = ui->add_formula->text();
	  			setEnabled(false);
	  			addFormula->clearLine();
	  			addFormula->braketsCount = 0;
	  			addFormula->l = literals;
	  			addFormula->updateButtons();
	  			addFormula->show();
	  		}
	  		
	  	}
	  	
	  	void MainWindow::closeAddFormula()
	  	{
	  		setEnabled(true);
	  		addFormula->reject();
	  	}
	  	
	  	void MainWindow::saveFormula()
	  	{
	  		if (lastButton == ui->addTheorem->text()){
	  			if (!addFormula->getFormula().isEmpty()){
	  				theorem = addFormula->getFormula();
	  				updateTheorem();
	  				setEnabled(true);
	  				addFormula->reject();
	  			}
	  			else{
	  				QMessageBox::information(this, "Ошибка!", "Формула пуста!");
	  			}
	  		}
	  		else if(lastButton == ui->add_formula->text()){
	  			if (!addFormula->getFormula().isEmpty() && !formulas.contains(addFormula->getFormula())){
	  				formulas.append(addFormula->getFormula());
	  				updateFormulas();
	  				setEnabled(true);
	  				addFormula->reject();
	  			}
	  			else if(formulas.contains(addFormula->getFormula())){
	  				QMessageBox::information(this, "Ошибка!", "Такая формула уже есть!");
	  				showAddFormula();
	  			}
	  			else{
	  				QMessageBox::information(this, "Ошибка!", "Формула пуста!");
	  				setEnabled(true);
	  				addFormula->reject();
	  			}
	  		}
	  	}
	  	
	  	void MainWindow::deleteFormula()
	  	{
	  		if(formulas.size() > 0){
	  			formulas.pop_back();
	  			updateFormulas();
	  		}
	  		else{
	  			QMessageBox::information(this, "Ошибка!", "Формул нет!");
	  		}
	  	}
	  	
	  	void MainWindow::deleteTheorem()
	  	{
	  		theorem.clear();
	  		ui->theorem->clear();
	  	}
	  	
	  	void MainWindow::showResolution()
	  	{
	  		if (ui->theorem->count()){
	  			setEnabled(false);
	  			res->literals = this->literals;
	  			res->formulas = this->formulas;
	  			res->theorem = this->theorem;
	  			res->S.clear();
	  			res->update();
	  			res->show();
	  		}
	  		else{
	  			QMessageBox::information(this, "Ошибка!", "Введите гипотезу!");
	  		}
	  	}
	  	
	  	void MainWindow::closeResolution()
	  	{
	  		setEnabled(true);
	  		res->reject();
	  	}
	  \end{cppcode}
	  \begin{center}
	  	\textbf{Файл Formula.h}
	  \end{center}
	  \begin{cppcode}[caption = Файл Formula.h]
	  	
	  	#ifndef FORMULA_H
	  	#define FORMULA_H
	  	
	  	#include <QDialog>
	  	#include <QSet>
	  	#include <QString>
	  	#include <QKeyEvent>
	  	
	  	namespace Ui {
	  		class formula;
	  	}
	  	
	  	class formula : public QDialog
	  	{
	  		Q_OBJECT
	  		
	  		public:
	  		explicit formula(QWidget *parent = nullptr);
	  		~formula();
	  		QVector<QString> l;//массив литералов
	  		int braketsCount;
	  		
	  		void updateButtons();
	  		void addButtonsToLayout(const QVector<QString> &vector);
	  		QString getFormula();
	  		void clearLine();
	  		bool check();
	  		
	  		private:
	  		Ui::formula *ui;
	  		int row, column;//для располо
	  		
	  		QVector<QString> buttons;
	  		
	  		void connectAllButtons();
	  		
	  		public slots:
	  		void close();
	  		void onButtonClicked(const QString &text);
	  		void backspace();
	  		
	  		void save();
	  		
	  		signals:
	  		void closeSignal();
	  		void saveSignal();
	  		void backspacePressed();
	  		
	  		protected:
	  		void closeEvent(QCloseEvent* event) override;
	  		void keyPressEvent(QKeyEvent *event) override;
	  		
	  	};
	  	
	  	#endif // FORMULA_H
	  	
	  \end{cppcode}
	  \begin{center}
	  	\textbf{Файл Formula.h}
	  \end{center}
	  \begin{cppcode}[caption = Файл Formula.cpp]
	  	#include "formula.h"
	  	#include "ui_formula.h"
	  	#include <QMessageBox>
	  	
	  	formula::formula(QWidget *parent) :
	  	QDialog(parent), row(0), column(0), braketsCount(0),
	  	ui(new Ui::formula)
	  	{
	  		ui->setupUi(this);
	  		
	  		connectAllButtons();
	  	}
	  	
	  	
	  	void formula::addButtonsToLayout(const QVector<QString> &vector)
	  	{
	  		for (const QString &buttonText : vector) {
	  			QPushButton *button = new QPushButton(buttonText, this);
	  			connect(button, &QPushButton::clicked, this, [this, buttonText]() {
	  				onButtonClicked(buttonText);
	  			});
	  			ui->gridLayout->addWidget(button, row, column);
	  			column++;
	  			if (column >= 4) {
	  				column = 0;
	  				row++;
	  			}
	  		}
	  	}
	  	
	  	QString formula::getFormula()
	  	{
	  		return ui->lineEdit->text();
	  	}
	  	
	  	void formula::clearLine()
	  	{
	  		ui->lineEdit->clear();
	  	}
	  	
	  	bool formula::check()
	  	{
	  		auto isPartOfSet = [](const QString &ch, const QVector<QString> &set) -> bool {
	  			return set.contains(ch);
	  		};
	  		
	  		QVector<QString> specialSet = {"*", "+", "->", "=="};
	  		QString str = ui->lineEdit->text();
	  		int eq = 0;
	  		
	  		
	  		if(braketsCount || str[0] == "+" || str[0] == "*") return false;
	  		
	  		if(str.contains("-") && !str.contains("->")) return false;
	  		
	  		for (int i = 0; i < str.length(); ++i) {
	  			// Check if the current character and the next character are both in l
	  			if (i < str.length() - 1 && isPartOfSet(str.mid(i, 1), l) && isPartOfSet(str.mid(i + 1, 1), l)) {
	  				return false;
	  			}
	  			if (str[i] == "=") eq++;
	  			
	  			
	  			// Check if the current character and the next character are both in specialSet
	  			for (const QString &special : specialSet) {
	  				if (i < str.length() - special.length() && str.mid(i, special.length()) == special &&
	  				str.mid(i + special.length(), special.length()) == special) {
	  					return false;
	  				}
	  				if (str.endsWith(special) || str.endsWith("!")) return false;
	  			}
	  		}
	  		if(eq % 2) return false;
	  		
	  		return true;
	  	}
	  	
	  	void formula::connectAllButtons()
	  	{
	  		connect(ui->close_button, &QPushButton::clicked, this, &formula::close);
	  		connect(ui->backspace, &QPushButton::clicked, this, &formula::backspace);
	  		connect(ui->save_button, &QPushButton::clicked, this, &formula::save);
	  		connect(this, &formula::backspacePressed, this, &formula::backspace);
	  		
	  		buttons << "!" << "+" << "*" << "->" << "==" << "(" << ")";
	  		addButtonsToLayout(buttons);
	  	}
	  	
	  	
	  	formula::~formula()
	  	{
	  		delete ui;
	  	}
	  	
	  	void formula::updateButtons()
	  	{
	  		QLayoutItem *item;
	  		while ((item = ui->gridLayout->takeAt(0)) != nullptr) {
	  			delete item->widget();
	  			delete item;
	  		}
	  		row = 0;
	  		column = 0;
	  		
	  		addButtonsToLayout(buttons);
	  		addButtonsToLayout(l);
	  	}
	  	
	  	
	  	
	  	void formula::close()
	  	{
	  		emit closeSignal();
	  	}
	  	
	  	void formula::onButtonClicked(const QString &text)
	  	{
	  		QString currentText = ui->lineEdit->text();
	  		QString operations = "+*->==!(";
	  		
	  		if(text == "(" && !currentText.isEmpty()){
	  			if(!l.contains(currentText.at(currentText.size() - 1))){
	  				braketsCount++;
	  				ui->lineEdit->setText(currentText + text);
	  			}
	  			else{
	  				
	  			}
	  		}
	  		else if (text == "(" && currentText.isEmpty()){
	  			braketsCount++;
	  			ui->lineEdit->setText(currentText + text);
	  		}
	  		else if (text == ")" && braketsCount == 0){
	  			QMessageBox::information(this, "Ошибка!", "Нет открытых скобок!");
	  		}
	  		else if (text == ")" && braketsCount > 0) {
	  			if(braketsCount > 0 && (currentText.at(currentText.size() - 1) == ')' ||
	  			l.contains(currentText.at(currentText.size() - 1)))){
	  				braketsCount--;
	  				ui->lineEdit->setText(currentText + text);
	  			}
	  			else{
	  				
	  			}
	  		}
	  		else if (currentText.isEmpty() && !l.contains(text) && text != "!"){
	  			
	  		}
	  		else if (text == "+" || text == "->" || text == "*" || text == "==") {
	  			if(operations.contains(currentText.at(currentText.size() - 1))){
	  				
	  			}
	  			else{
	  				ui->lineEdit->setText(currentText + text);
	  			}
	  		}
	  		else {
	  			ui->lineEdit->setText(currentText + text);
	  		}
	  	}
	  	
	  	void formula::backspace()
	  	{
	  		QString currentText = ui->lineEdit->text();
	  		if(!currentText.isEmpty()){
	  			if(currentText.at(currentText.length() - 1) == ')') braketsCount++;
	  			if(currentText.at(currentText.length() - 1) == '(') braketsCount--;
	  			currentText.chop(1);
	  			ui->lineEdit->clear();
	  			ui->lineEdit->setText(currentText);
	  		}
	  		else{
	  			QMessageBox::information(this, "Ошибка!", "Формула пуста!");
	  		}
	  	}
	  	
	  	void formula::save()
	  	{
	  		if(check()){
	  			emit saveSignal();
	  		}
	  		else{
	  			QMessageBox::information(this, "Ошибка!", "Неверная формула!");
	  		}
	  		
	  	}
	  	
	  	void formula::closeEvent(QCloseEvent *event)
	  	{
	  		emit closeSignal();
	  	}
	  	
	  	void formula::keyPressEvent(QKeyEvent *event)
	  	{
	  		if (event->key() == Qt::Key_Backspace) {
	  			emit backspacePressed();
	  		}
	  		else if (event->key() == Qt::Key_Return){
	  			emit saveSignal();
	  		}
	  		else if (event->key() == Qt::Key_Escape){
	  			emit closeSignal();
	  		}
	  		else {
	  			QWidget::keyPressEvent(event);
	  		}
	  	}
	  	
	  \end{cppcode}
	  \begin{center}
	  	\textbf{Файл Resolution.h}
	  \end{center}
	  \begin{cppcode}[caption = Файл Resolution.h]
	  	#ifndef RESOLUTION_H
	  	#define RESOLUTION_H
	  	
	  	#include <QDialog>
	  	
	  	
	  	namespace Ui {
	  		class resolution;
	  	}
	  	
	  	class resolution : public QDialog
	  	{
	  		Q_OBJECT
	  		
	  		public:
	  		explicit resolution(QWidget *parent = nullptr);
	  		~resolution();
	  		friend class MainWindow;
	  		
	  		void update();
	  		
	  		private:
	  		Ui::resolution *ui;
	  		QVector<QString> literals;//массив литералов
	  		QVector<QString> formulas;//массив допущений
	  		QStringList S;//дизъюнкты
	  		QString theorem;
	  		
	  		
	  		QSet<QString> splitDisjunct(const QString& str);
	  		
	  		
	  		
	  		void formulaToS(const QString& str);
	  		void applyResolution();
	  		
	  		void removeBrackets(QString& str);
	  		
	  		void printResult(QString t);
	  		
	  		//приведение к кнф
	  		void removeImplication(QString& str);//избавляемся от -> Рабочая
	  		void removeEq(QString& str);//избавляемся от ==  Рабочая
	  		
	  		void removeNotBrackets(QString& str);//избавляемся от !( Рабочая
	  		
	  		void removeDoubleNot(QString& str);//избавляемся от двойного отрицания Рабочая
	  		void replaceParentheses(QString& str);//упрощение
	  		
	  		void ToCNF(QString& str);
	  		
	  		bool hasNoContradiction(const QString &formula);
	  		void removeDuplicateLiterals(QString &formula);
	  		
	  		
	  		public slots:
	  		void close();
	  		
	  		signals:
	  		void closeSignal();
	  		
	  		protected:
	  		void closeEvent(QCloseEvent* event) override;
	  	};
	  	
	  	#endif // RESOLUTION_H
	  	
	  \end{cppcode}
	  \begin{center}
	  	\textbf{Файл Resolution.cpp}
	  \end{center}
	  \begin{cppcode}[caption = Файл Resolution.cpp]
	  	#include "resolution.h"
	  	#include "ui_resolution.h"
	  	
	  	resolution::resolution(QWidget *parent) :
	  	QDialog(parent),
	  	ui(new Ui::resolution)
	  	{
	  		ui->setupUi(this);
	  		
	  		connect(ui->close, &QPushButton::clicked, this, &resolution::closeSignal);
	  		
	  		ui->result->setAlignment(Qt::AlignTop | Qt::AlignJustify);
	  		ui->result->setWordWrap(true);
	  	}
	  	
	  	resolution::~resolution()
	  	{
	  		delete ui;
	  	}
	  	
	  	void resolution::update()
	  	{
	  		ui->formulas->clear();//отображение дизъюнктов и вывода из S
	  		for (QString& str : formulas) {//добавляем дизъюнкты
	  			str.insert(0,'(');//обернуть в скобки
	  			str.append(')');
	  			ToCNF(str);
	  			formulaToS(str);
	  		}
	  		QString tmp = theorem;
	  		theorem.insert(0,"!(");
	  		theorem.append(')');
	  		ToCNF(theorem);
	  		formulaToS(theorem);
	  		applyResolution();
	  		ui->formulas->addItems(S);
	  		printResult(tmp);
	  	}
	  	
	  	QSet<QString> resolution::splitDisjunct(const QString &str)
	  	{
	  		return QSet<QString>::fromList(str.split("+"));
	  	}
	  	
	  	void resolution::applyResolution()
	  	{
	  		bool newDisjunctAdded = true;
	  		while (newDisjunctAdded) {
	  			newDisjunctAdded = false;
	  			QStringList newDisjuncts;
	  			for (int i = 0; i < S.size(); ++i) {
	  				for (int j = i + 1; j < S.size(); ++j) {
	  					QSet<QString> disjunct1 = splitDisjunct(S[i]);//множество слагаемых
	  					QSet<QString> disjunct2 = splitDisjunct(S[j]);
	  					bool foundContradiction = false;
	  					QString literalToRemove;
	  					QString negatedLiteralToRemove;
	  					for (const QString& literal : disjunct1) {
	  						QString negatedLiteral = (literal.startsWith("!") ? literal.at(1) : "!" + literal);
	  						if (disjunct2.contains(negatedLiteral)) {
	  							foundContradiction = true;
	  							literalToRemove = literal;
	  							negatedLiteralToRemove = negatedLiteral;
	  							break;
	  						}
	  					}
	  					if (foundContradiction) {//елси найдены
	  						QSet<QString> resolvent = disjunct1;
	  						resolvent.unite(disjunct2);
	  						resolvent.remove(literalToRemove);
	  						resolvent.remove(negatedLiteralToRemove);
	  						if (resolvent.isEmpty()) {
	  							// В случае, если resolvent пустое, добавляем строку "0"
	  							if (!S.contains("0")) {
	  								newDisjuncts.append("0");
	  								newDisjunctAdded = true;
	  							}
	  						} else {
	  							QString resolventStr = QStringList(resolvent.toList()).join("+");
	  							removeDuplicateLiterals(resolventStr);
	  							if (!S.contains(resolventStr) && hasNoContradiction(resolventStr)) {
	  								newDisjuncts.append(resolventStr);
	  								newDisjunctAdded = true;
	  							}
	  						}
	  					}
	  				}
	  			}
	  			newDisjuncts.removeDuplicates();
	  			S.append(newDisjuncts);
	  		}
	  	}
	  	
	  	void resolution::formulaToS(const QString &str)
	  	{
	  		if(!str.isEmpty()){
	  			QStringList substrings = str.split('*');
	  			for (QString& s : substrings) {
	  				removeBrackets(s);
	  				S.append(s);
	  			}
	  			S.removeDuplicates();
	  		}
	  		
	  	}
	  	
	  	void resolution::removeBrackets(QString &str)
	  	{
	  		str.remove('(');
	  		str.remove(')');
	  	}
	  	
	  	
	  	void resolution::printResult(QString t)
	  	{
	  		
	  		if (S.contains("0")){
	  			ui->result->setText("Формула " + t + " является логическим следствием "
	  			"исходного множества формул! Так как из S"
	  			" можно вывести пустой дизъюнкт '0'.");
	  		}
	  		else{
	  			ui->result->setText("Формула " + t + " не является логическим следствием "
	  			"исходного множества формул! Так как из S "
	  			"нельзя вывести пустой дизъюнкт '0'.");
	  		}
	  	}
	  	
	  	void resolution::removeImplication(QString &str)
	  	{
	  		while(str.contains("->")){
	  			for (int i = 0; i < str.size(); i++ ) {
	  				if(str.at(i) == '-'){//импликация
	  					QString left;
	  					QString right;
	  					int indexToReplace;
	  					
	  					str.replace(i, 2, '+');//заменяем на +
	  					if(str.at(i-1) == ')'){//если перед импликпцией скобка, то нужно вставить отрицание перед
	  						//скобкой
	  						int closedBrackets = 1;
	  						int openBrackets = 0;
	  						left += ")";
	  						for (int j = i - 2;j >= 0 ; j--) {
	  							if (str.at(j) == ')') closedBrackets++;
	  							if (str.at(j) == '(') openBrackets++;
	  							left.insert(0, str.at(j));
	  							if (closedBrackets == openBrackets){//нужно вставить отрицание
	  								indexToReplace = j;
	  								//str.insert(j, "(!");
	  								break;
	  							}
	  						}
	  					}
	  					if(left.isEmpty()){//если слева буква или ее отрицание
	  						left += str.at(i-1);
	  						if(i-2 >= 0){
	  							if (str.at(i-2) == '!'){
	  								left.insert(0, '!');
	  								indexToReplace = i-2;
	  							}
	  							else{
	  								indexToReplace = i-1;
	  							}
	  						}
	  						else{
	  							indexToReplace = i-1;
	  						}
	  					}
	  					if(str.at(i+1) == '('){//если справа скобка
	  						int closedBrackets = 0;
	  						int openBrackets = 1;
	  						right += "(";
	  						for (int j = i + 2; j < str.size(); j++ ) {//перебираем символы вправо
	  							right.append(str.at(j));
	  							if (str.at(j) == ')') closedBrackets++;
	  							if (str.at(j) == '(') openBrackets++;
	  							if (openBrackets == closedBrackets){
	  								break;
	  							}
	  						}
	  					}
	  					if(str.at(i+1) == '!' && str.at(i+2) != '('){//если справа отрицание буквы
	  						right = '!' + str.at(i+2);
	  					}
	  					if(str.at(i+1) != '!' && str.at(i+1) != '('){//если справа просто буква
	  						right += str.at(i+1);
	  					}
	  					if(str.at(i+1) == '!' && str.at(i+2) == '('){//если справа отрицание скобки
	  						int openBrackets = 1;
	  						int closedBrackets = 0;
	  						right += "!(";
	  						for (int j = i + 3; j < str.size(); j++ ) {//перебираем символы вправо
	  							right.append(str.at(j));
	  							if (str.at(j) == ')') closedBrackets++;
	  							if (str.at(j) == '(') openBrackets++;
	  							if (openBrackets == closedBrackets){
	  								break;
	  							}
	  						}
	  					}
	  					QString newStr = "(!" + left + "+" + right + ")";
	  					str.replace(indexToReplace, left.size() + 1 + right.size(), newStr);
	  					QRegularExpression re("!!");
	  					str.replace(re, "");
	  				}
	  			}
	  		}
	  	}
	  	
	  	void resolution::removeEq(QString &str)
	  	{
	  		while(str.contains("==")){
	  			for (int i = 0; i < str.size(); i++){
	  				if(str.at(i) == '='){//индекс эквивалентности
	  					QString left;
	  					QString right;
	  					int indexToReplace;
	  					str.replace(i, 2, '*');
	  					if(str.at(i-1) == ')'){//если слева скобка
	  						int closedBrackets = 1;
	  						int openBrackets = 0;
	  						
	  						left += ")";
	  						for (int j = i - 2;j >= 0 ; j--){//перебираем символы влево
	  							left.insert(0,str.at(j));//добавляем в левую часть
	  							if (str.at(j) == ')') closedBrackets++;
	  							if (str.at(j) == '(') openBrackets++;
	  							
	  							if (closedBrackets == openBrackets){//нужно вставить отрицание
	  								indexToReplace = j;
	  								break;
	  							}
	  						}
	  					}
	  					if(str.at(i+1) == '('){//если справа скбока
	  						int openBrackets = 1;
	  						int closedBrackets = 0;
	  						right += "(";
	  						for (int j = i + 2; j < str.size(); j++ ) {//перебираем символы вправо
	  							right.append(str.at(j));
	  							if (str.at(j) == ')') closedBrackets++;
	  							if (str.at(j) == '(') openBrackets++;
	  							if (openBrackets == closedBrackets){
	  								break;
	  							}
	  						}
	  					}
	  					if(str.at(i+1) == '!' && str.at(i+2) != '('){//если справа отрицание буквы
	  						right = '!' + str.at(i+2);
	  					}
	  					if(str.at(i+1) == '!' && str.at(i+2) == '('){//если справа отрицание скобки
	  						int openBrackets = 1;
	  						int closedBrackets = 0;
	  						right += "!(";
	  						for (int j = i + 3; j < str.size(); j++ ) {//перебираем символы вправо
	  							right.append(str.at(j));
	  							if (str.at(j) == ')') closedBrackets++;
	  							if (str.at(j) == '(') openBrackets++;
	  							if (openBrackets == closedBrackets){
	  								break;
	  							}
	  						}
	  					}
	  					if (str.at(i+1) != '(' && str.at(i+1) != '!'){//если справа просто буква
	  						right += str.at(i+1);
	  					}
	  					if(left.isEmpty()){//если слева буква или ее отрицание
	  						left += str.at(i-1);
	  						if(i-2 >= 0){
	  							if (str.at(i-2) == '!'){
	  								left.insert(0, '!');
	  								indexToReplace = i-2;
	  							}
	  							else{
	  								indexToReplace = i-1;
	  							}
	  						}
	  						else{
	  							indexToReplace = i-1;
	  						}
	  					}
	  					QString newStr = "((!" + left + "+" + right + ")*(" + left +"+!" + right + "))";
	  					str.replace(indexToReplace, left.size() + 1 + right.size(), newStr);
	  					QRegularExpression re("!!");
	  					str.replace(re, "");
	  				}
	  			}
	  		}
	  	}
	  	
	  	void resolution::removeNotBrackets(QString &str)
	  	{
	  		while(str.contains("!(")){
	  			for (int i = 0; i < str.size(); i++) {
	  				if(str.at(i) == '!'){//отрицание
	  					QString subString;
	  					QString left;
	  					QString right;
	  					QString operation;
	  					int operationIndex = 0;
	  					int endIndex;
	  					if(str.at(i+1) != '('){//если отрицание литерала, то ничего не делаем
	  						
	  					}
	  					else{//если отрицание скобки
	  						int openBrackets = 1;
	  						int closedBrackets = 0;
	  						int level = 0;
	  						for (int j = i + 2; i < str.size(); j++) {
	  							if (str.at(j) == '('){
	  								level++;
	  								openBrackets++;
	  							}
	  							if (str.at(j) == ')'){
	  								level--;
	  								closedBrackets++;
	  							}
	  							if(level == 0 && (str.at(j) == '+' || str.at(j) == '*')){
	  								if(str.at(j) == '+') operation = "*";
	  								else operation = "+";
	  								operationIndex = j;
	  							}
	  							subString.append(str.at(j));
	  							if (openBrackets == closedBrackets){
	  								subString.chop(1);
	  								endIndex = j;
	  								break;
	  							}
	  						}
	  						if(operationIndex != 0){//внутри есть операция
	  							left = str.mid(i+2, operationIndex - i - 2);//левая часть внутри скобки
	  							right = str.mid(operationIndex + 1, endIndex - operationIndex - 1);
	  							str.replace(i, endIndex - i + 1, "(!(" + left + ")" + operation + "!(" + right + "))");
	  						}
	  						else{//внутри нет операции
	  							str.remove(i+1, 1);
	  							str.remove(endIndex-1, 1);
	  						}
	  					}
	  				}
	  			}
	  		}
	  	}
	  	
	  	void resolution::removeDoubleNot(QString &str)
	  	{
	  		QRegularExpression re("!!");
	  		str.replace(re,"");
	  	}
	  	
	  	void resolution::replaceParentheses(QString &str)
	  	{
	  		QString previous = str;
	  		do{
	  			previous = str;
	  			
	  			for(int i = 0; i < str.size(); i++){
	  				int endIndex;
	  				QString subString;
	  				QString oprationsOnLevelZero;
	  				int openBrackets = 1;
	  				int closedBrackets = 0;
	  				int level = 0;
	  				int lastOpIndex = i + 1;
	  				QStringList slag;
	  				QStringList mul;
	  				QString res;
	  				QString lastOp;
	  				
	  				if(str.at(i) == '('){
	  					for(int j = i + 1; j < str.size(); j++){
	  						subString.append(str.at(j));
	  						if (str.at(j) == '('){
	  							level++;
	  							openBrackets++;
	  						}
	  						if (str.at(j) == ')'){
	  							level--;
	  							closedBrackets++;
	  						}
	  						if(level == 0 && str.at(j) == '+'){
	  							oprationsOnLevelZero.append('+');
	  						}
	  						if(level == 0 && str.at(j) == '*'){
	  							oprationsOnLevelZero.append('*');
	  						}
	  						if (openBrackets == closedBrackets){
	  							subString.chop(1);
	  							endIndex = j;
	  							break;
	  						}
	  					}
	  					if(oprationsOnLevelZero.contains('*') && !oprationsOnLevelZero.contains('+')){//CNF
	  						str.replace(i, endIndex - i + 1, subString);
	  						continue;
	  					}
	  					if(oprationsOnLevelZero.isEmpty()){//лишние скобки
	  						str.replace(i, endIndex - i + 1, subString);
	  						continue;
	  					}
	  					if(oprationsOnLevelZero.contains('+') && !oprationsOnLevelZero.contains('*')){//толко плюсы
	  						continue;
	  					}
	  					if(oprationsOnLevelZero.contains('*') && oprationsOnLevelZero.contains('+')){
	  						QString tmp;
	  						int level = 0;
	  						bool lastOpIsMul = false;
	  						for(int j = 0; j < subString.size(); j++){
	  							if(subString.at(j) == '(') level++;
	  							if(subString.at(j) == ')') level--;
	  							tmp.append(subString.at(j));
	  							if((subString.at(j) == '*' || lastOpIsMul) && level == 0 && (subString.at(j) == '*' || subString.at(j) == '+')){
	  								tmp.chop(1);
	  								mul.append(tmp);
	  								tmp.clear();
	  								lastOpIndex = j;
	  								if(subString.at(j) == '+'){
	  									lastOpIsMul = false;
	  								}
	  								if(subString.at(j) == '*'){
	  									lastOpIsMul = true;
	  								}
	  								continue;
	  							}
	  							if(subString.at(j) == '+' && level == 0){
	  								tmp.chop(1);
	  								slag.append(tmp);
	  								tmp.clear();
	  								lastOpIndex = j;
	  								lastOpIsMul = false;
	  							}
	  						}
	  						if(subString.at(lastOpIndex) == '+'){
	  							slag.append(subString.mid(lastOpIndex+1));
	  						}
	  						if(subString.at(lastOpIndex) == '*'){
	  							mul.append(subString.mid(lastOpIndex+1));
	  						}
	  						res = "(" + slag.join("+") + "+" + mul.at(0) + ")*(";
	  						mul.removeFirst();
	  						res += slag.join("+") + "+" + mul.join('*') + ")";
	  					}
	  					str.replace(i, subString.size()+2, res);
	  					res.clear();
	  					slag.clear();
	  					mul.clear();
	  				}
	  			}
	  		}while(str != previous);
	  	}
	  	
	  	void resolution::ToCNF(QString &str)
	  	{
	  		removeEq(str);
	  		removeImplication(str);
	  		removeNotBrackets(str);
	  		removeDoubleNot(str);
	  		replaceParentheses(str);
	  		
	  		QStringList res;
	  		QStringList tmp = str.split('*');
	  		for (QString& s : tmp) {
	  			removeBrackets(s);
	  			if(hasNoContradiction(s)){
	  				removeDuplicateLiterals(s);
	  				res.append(s);
	  			}
	  		}
	  		
	  		str = res.join('*');
	  		
	  	}
	  	
	  	bool resolution::hasNoContradiction(const QString &formula)
	  	{
	  		QSet<QString> literals;
	  		QStringList parts = formula.split('+');
	  		for (const QString &part : parts) {
	  			QString literal = part.trimmed();
	  			if (literal.startsWith('!')) {
	  				// Проверка на наличие отрицательного литерала
	  				QString positiveLiteral = literal.mid(1);
	  				if (literals.contains(positiveLiteral)) {
	  					return false;
	  				}
	  				literals.insert(literal);
	  			} else {
	  				// Проверка на наличие положительного литерала
	  				QString negativeLiteral = '!' + literal;
	  				if (literals.contains(negativeLiteral)) {
	  					return false;
	  				}
	  				literals.insert(literal);
	  			}
	  		}
	  		return true;
	  	}
	  	
	  	void resolution::removeDuplicateLiterals(QString &formula)
	  	{
	  		QSet<QString> uniqueLiterals;
	  		QStringList parts = formula.split('+');
	  		QStringList result;
	  		
	  		for (const QString &part : parts) {
	  			QString literal = part.trimmed();
	  			if (!uniqueLiterals.contains(literal)) {
	  				uniqueLiterals.insert(literal);
	  				result.append(literal);
	  			}
	  		}
	  		
	  		formula = result.join('+');
	  	}
	  	
	  	
	  	
	  	void resolution::close()
	  	{
	  		emit closeSignal();
	  	}
	  	
	  	void resolution::closeEvent(QCloseEvent *event)
	  	{
	  		emit closeSignal();
	  	}
	  	
	  \end{cppcode}
	  \begin{center}
	  	\textbf{Файл main.cpp}
	  \end{center}
	  \begin{cppcode}[caption = Файл main.cpp]
	  	#include "mainwindow.h"
	  	
	  	
	  	#include <QApplication>
	  	
	  	int main(int argc, char *argv[])
	  	{
	  		QApplication a(argc, argv);
	  		MainWindow w;
	  		w.show();
	  		return a.exec();
	  	}
	  	
	  \end{cppcode}
\end{document}
